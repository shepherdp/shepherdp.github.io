<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>


<div class="topbar">
  <h2>Projects</h2>
</div>

<div class="sidenav">
  <a href="./index.html">Intro</a>
  <a href="./projects.html">Projects</a>
  <a href="./publications.html">Publications</a>
  <a href="./writings.html">Writings</a>
  <a href="./resume.html">Resume</a>
</div>

<div class="main">
  <div>
    <p>( ^ w ^ ) Peekaboo!</p>
  </div>

  <button type="button" class="collapsible">TeamMaker</button>
  <div class="content" style="display:block">
      <div class="normaltext">
        <p>Creators: Silas Fair, Tojo Tsimalay, Zaki Ayoubi, Patrick Shepherd</p>
        <p>Over the summer of 2023, I led a team of three students in building a web interface for a tool I had been
        using in class.  Here's the use case:</p>
        <p>Imagine you are in charge of training a group of 20 people in a set of software tools.  This training will
        take several weeks, so you want to keep the participants engaged and excited with their work, rather than
        dipping into training tedium.  You have decided that a great way to train your participants is to create
        exploratory exercises in which you teach them a part of the software, and then ask them to solve some problems
        designed to highlight that functionality.  To encourage collaborative problem-solving and team responsibility,
        you split your participants into five groups of four people each.  You throw the names into a hat and draw
        them out four at a time, and you have your groups.  Wonderful!</p>
        <p>Two days of activities go by, and you realize that keeping everyone working with the same set of partners
        for weeks on end will hurt your goal of fostering the ability to collaborate with a wide range of people, so you
        decide to start changing groups each day.  You draw names out of a hat again and make groups, only to realize
        that several people are now in groups with some of the people they have already worked with.  You do the hat
        thing again, and realize that this method just isn't good enough.  You write all the names down on a piece of
        paper, along with previous group assignments, and laboriously find a new matching of participants such that
        everone is now in groups with <em>only</em> new partners.  Wonderful!</p>
        <p>A week goes by, and you realize that re-grouping people in this way is too mentally taxing on the one hand,
        and insufficient on the other.  After three or four re-groupings, there is no possibility of everyone working
        with new partners, so you have to find a way to <em>maximize</em> the number of new partners, understanding that
        the number of possible new partnerships goes down with each new group assignment.  Additionally, there have been
        one or two personal conflicts between partners, and you know you need to not group them together in the future.
        ADDITIONALLY additionally, some participants are taking to the material much more quickly than others, and you
        notice that when a group is made that only contains members that need more help, the experience is worse and
        less productive for all of them.  If only there were, say, a web platform one could use to assign a group of
        people to different teams over and over again according to constraints like these...</p>
        <object data="/pdfs/Teammaker_Poster.pdf" type="application/pdf" width="100%" height="500px"></object>
        <p>Over the course of two months, my students successfully came together to accomplish an amazing taks:
        building and deploying the tool described above.  TeamMaker is an online platform that allows educators,
        corporate trainers, etc. to upload a list of participants, and then repeatedly group them into teams based on
        the criteria laid out by the user.  Tojo was the web engineer, showing off his skills in web development to
        build the user interface and authentication framework.  Silas was our algorithms expert who designed three
        different placement algorithms depending on your needs.  Zaki was our data master, designing and incorporating
        database functionality into the website to allow for anyone to make an account and store as many different
        classes of participants as they like.  Together, my team showed enormous ingenuity and created a product that
        can be used in a diverse array of contexts, from schools to the training room.</p>
        <a href="https://teammakeronline.com" target="_blank">Visit TeamMaker today!</a>
      </div>
  </div>

  <button type="button" class="collapsible">SNEE (Social Network Evolution Engine)</button>
  <div class="content">
      <div class="normaltext">
        <p>SNEE is a suite of tools that is designed to handle diverse experimental designs for examining social network
          evolution.  My last three years of graduate school were when I began my study of simulated social dynamics
          by looking into opinion diffusion.  After studying the topic for several months, it became apparent that the
          majority of popular models for opinion diffusion were really just special cases of a more general
          hyperparameter space.  Thus, the first version of SNEE was born (although I didn't decide to call it that
          until a few months before graduation)!
        </p>
        <p>The software is still a work in progress, but it is very powerful in its current form.  For starters, the
          interface allows you to define all sorts of general parameters describing your network.
        </p>
        <ul>
          <li>How many people are you simulating?</li>
          <li>Is influence bidirectional? (e.g. do person A and person B influence each other, or does it only go one
            way?)</li>
          <li>Is influence strength constant, or do some people hold more influence than others?</li>
          <li>How many opinions does each person have?</li>
          <li>Are opinions of the form "yes or no", or do they exist on a spectrum?</li>
          <li>Can people acquire new friends?  If so, how do they decide who to become friends with?</li>
          <li>Can people lose friends?  If so, how does that happen?</li>
          <li>And much more!</li>
        </ul>
        <p>The platform allows you to define the characteristics of your network in fine detail, with sensible presets
          available for demonstration.  The platform doesn't only handle opinion diffusion, though; any mutable
          individual characteristic (e.g. language, information, preferences, etc.) can be modeled in this way.
          SNEE also has support for diffusion processes that propagate over categorical variables - that is, things like
          disease where each agent can be in one of several states at any given time, like "healthy," "sick," or
          "immune."  The rules for the propagation of this sort of phenomenon can also be defined manually.
        </p>
        <img src="/imgs/snee1.png" class="center">
        <p>Above is an image from SNEE of a network with 100 people, bidirectional influence, and a single opinion each.
          the color and size of each node is based on its betweenness centrality (a metric judging how much of a
          bottleneck an individual is with respect to the simulated process), and the network has been constructed with
          a "scale free" topology, meaning that a few people have many connections, and most people have few.  You also
          probably noticed the panel on the left side of the screen.  That's where you get to control all the visual
          aspects of your display, such as how to color and size the individual nodes, and how fast to animate the
          visualization.  Oh right, I forgot to mention that: my platform allows you to watch the diffusion process play
          out in real time instead of waiting for a program to run and then sifting through endless spreadsheets.  If AI
          has taught us anything recently, it's that there are some jobs a human looking at an event can do better than
          a computer processing data about that same event.
        </p>
        <p>I don't want to sound like I am speaking ill of data, though.  That's why I added a feature that allows the
          user to automatically incorporate up to six subplots underneath the visualization of the network itself which
          can display all the metrics you would usually be looking at: network density, various centrality metrics, and
          even summary statistics about the diffusion (such as opinion change) itself.  Below is an example run in which
          each person has opinions on four topics, and generally speaking everyone likes being around people who are
          similar, and people also become more similar to those around them.  You can see in the bottom of the plot that
          the density of the network increases over time, as reflected in the degree metric.  Betweenness goes down over
          time, however, because as people become more and more connected to each other, there get to be fewer and fewer
          bottlenecks.
        </p>
        <img class="center" src="/imgs/sneerun1.gif">
        <p>That leads us to our next point: what about if our network is made up of a diverse group of people?  In other
          words, what if some people seek out dissimilarity?  What if people are rebellious and become <em>less</em>
          like those around them over time?  There are many questions like this that you can ask, and for this reason
          a major feature of the platform is the ability to define agent types - that is, you can create different
          subpopulations within your network that follow different behavioral rules over time, giving rise to some very
          interesting emergent properties across the network.  Runs that implement these types of agents can produce
          quite different results.
        </p>
        <img class="center" src="/imgs/sneerun2.gif">
        <p>In the GIF above, we have some (blue) agents that are just like the ones from the first animation.  Then we
        have some rebellious (orange) agents who like to buck trends and change their minds to go contrary to the
        majority.  Then we have some chill green agents who like being around people with a mix of agreement and
        disagreement with themselves.  You can see that in this case we still end up with a strong central chunk of
        the network, but the agents in it are all blue!  The greens and oranges don't get ejected entirely, but they
        do stay consistently less well-connected than those blues in the middle!  And this was only a single parameter
        setting; you can play with the likelihood that someone will friend or unfriend another person, the threshold
        of similarity they have to meet before they do that, the number of people who get to gain or lose friends per
        time step, the maximum number of friends they can gain or lose, etc.  All the dynamics of this process are
        parameterized in the interface, so you can tweak values to your heart's content, which incidentally makes models
        very easy to tune and evaluate against external data sources.</p>
      </div>
  </div>

  <button type="button" class="collapsible">Custom Assembler Simulation</button>
  <div class="content">
      <div class="normaltext">
        <p>A dozen years ago, you would never have been able to convince me that one day I would <em>really</em> know
        how computers work.  That was something that wizards did, you know?  Computer conjurers.  Silicon sorecerers.
        Masters of programming prestidigi... well, you get the idea.  Something for people smarter than myself.  I
        thought the same about physics, calculus, and on and on.  But then I took a programming class.</p>
        <p>I distinctly remember being in my first Python class, which was my first official experience programming
        anything ever.  I used to feel so confused by everything, and when the professor said that in order to be good
        programmers we would have to think like a compiler, I figured all hope was lost.  I would overhear other people
        in the class explaining topics to each other like they <em>really</em> understood what they were saying, and it
        was actually kind of discouraging at the time.  I felt too far behind to catch up.</p>
        <p>I won't bore you with a whole life story here, but I want to make the point: <b><em>ANYONE</em></b> can learn
        just about anything.  I kept on trying and trying to understand, and every time I would feel like I understood
        a new piece of programming, it would just lead me to think, "Okay, but then how does <em>that</em> work??"
        It seemed like no matter how far down I went, that same question would just keep coming up.  Okay, I can use a
        programming language, but how does <em>that</em> work?  Okay, it gets translated into machine code by a
        compiler, but how does <em>that</em> work?  Okay, the machine code gets mapped onto instructions in a chip on
        the motherboard, but how does <em>that</em> work?  Okay, the data lines can be on or off and there are control
        signals to tell the computer which chips need access to which data at each clock pulse, but how does
        <em>that</em> work?  Okay, now I understand that transistors, resistors, capacitors, etc. control the flow of
        electricity in the system so that signals always and only get where they need to go, but how does <em>that</em>
        work?</p>
        <p>When I went back to school, I stayed in for 10 years, and one thing I learned about myself is this: if I want
        to learn anything at all, the best way for me to do so is to put my hands on it and build one myself.  To that
        end, when I wanted to understand Assembly code better, I decided to just make my own.  Sure, it doesn't work
        with any currently used instruction set, but that wasn't the point.  The point was for me to build an assembler
        that is as versatile as actual assemblers in use today.</p>
        <img alt="My assembler computing Fibonacci numbers" class="center" src="/imgs/fib.gif">
        <p>What you see here is my assembler carrying out a full program.  What is the program, you ask?  No computer
        engineer will be surprised to learn that it is calculating Fibonacci numers!  Cliche?  Yes.  Valuable?  Also
        yes.  And anyone watching the program execute might notice that I didn't exactly do things the most efficient
        way... I'll fix that, I promise.  But I learned a great deal in doing this project, and I will be continuing
        work on it in the future.  Right now, it has a chunk of virtual memory, flags, registers, a program counter,
        and several instructions that can operate on literal values or dereference memory locations.</p>
        <p>One time a student approached me and said they wanted to work on projects for their portfolio, but had a kind
        of creativity paralysis where they couldn't settle on a project idea, and thus never got any coding done on
        their own.  They were "waiting for the right project."  They asked for my advice, and what I showed them was
        this.  I told them that this project is practically useless, in that it will never go into large scale
        production.  It won't be used by millions to solve the world's problems, and it won't disrupt any industries.
        But it does do a few things.  It helps me learn computer architecture better.  It helps me practice full-stack
        development by implementing a GUI to go along with the assembler itself.  It shows off my capabilities in
        quickly prototyping a design.  And importantly, it was a lot of fun.  Just like with that student, I encourage
        you to work on more "useless" projects.  They're much more valuable than they seem!</p>
      </div>
  </div>

  <button type="button" class="collapsible">City Builder Game</button>
  <div class="content">
      <div class="normaltext">
        <p>I don't know about you, but I loved playing video games as a kid.  I had two soft spots in gaming: flight
        simulation games, and city builders.  If you aren't familiar with the genre, a "city builder" is a
        management-focused game in which you, as the name suggests, build a city.  The challenge in these games comes
        from the interdependencies of all the moving parts involved.</p>
        <p>you want to build a city, you need people. If you want people, you need housing.  If you want housing, you
        need materials.  If you want materials, you need production facilities.  If you want those facilities to run,
        you need to maintain your population, which requires plenty of food, water, and other resources.  If you don't
        have enough production to satisfy your population, then people begin to leave, and so businesses slow down
        production even more, and the cycle feeds itself.  In general, the trick to these games is to develop things
        in such a way that each new development is well-supported by all the ones that came before it.</p>
        <p>As I was growing up, I played a lot of city building games, and I always had the same thought: I wish this
        game had <em>x</em> feature.  When I would play Age of Empires, I loved the military aspect, but always wanted
        a more robust economic system.  When I would play Caesar III or Pharaoh, I loved the city design aspects of
        the game, but I wanted the economy to be just a little more interconnecting, and the combat was awful.  When
        I would play Stronghold, the military was great and the economy was just slightly less complex than that of
        Pharaoh, but the buildings in your city could just be placed anywhere - there was no sense of design to it
        outside of making sure that things were close together to reduce villager travel time.  All of these games shone
        in their own areas, but I always felt like I was left wanting.  They all got part of it right, but never all
        in the same place at the same time.  So I decided to build my own.</p>
        <img src="imgs/city-builder.png" class="center">
        <p>Looks pretty rough if I'm being honest!  And it certainly is.  I don't claim to be an expert.  I wanted to
        know exactly how the games I love worked, and so I wanted to build the whole thing from scratch.  I built the
        engine from scratch, all of the images, all of the sounds, and all of the logic.  Every line of code in this
        game was written into an initially blank source file.  On my first day, I could draw a square grid on the
        screen.  On the second day, I could transform it to use isometric coordinates for perspective.  By the end of
        the first week, I had buildings, resources, usage rates, moving characters with different roles, a navmesh for
        the map so characters can find efficient paths to move around, and much more.</p>
        <p>This is my favorite personal project because, when it is complete, I'll have made the game I always wanted to
        play when I was a kid.  A complex economy, an evolving society, and a fluid military interface, all wrapped
        up in a single game.  One day I will certainly switch over to using professional engines, especially when I
        start looking to publish this program.  But until then, I'm just having fun learning everything I can about
        game development from the ground up.</p>
      </div>
  </div>

  <button type="button" class="collapsible">Custom Programming Language (SAFyR)</button>
  <div class="content">
      <div class="normaltext">
        <p>This is my most recent project, and so right now I unfortunately don't have much to show for it.  However,
        something that has always nagged at me since I was in school was the fact that I never had the chance to take
        a class in programming languages or compilers.  Web programming?  Check.  Networks?  Check.  Operating systems,
        AI, signal processing?  Check, check, check.  But no programming languages or compilers.  There is only one way
        in my mind to remedy that: open up a blank text file and start writing one from scratch.  So that's what I'm
        doing.</p>
        <p>At the moment, my language SAFyR is very early in development, but I am extremely proud to say that, a little
        thinking and one finite state machine later, the lexer for my language is complete!  I am currently working on
        the parser, but I will need to figure out more about the grammar I intend to use for my language before I can
        write a compiler to recognize it.  And who knows?  Maybe I'll even compile it down into my very own assembly
        language!  And then I'll need to design my own cpu...  This could take a while.  I'm all in!</p>
      </div>
  </div>

</div>

<script src="index.js"></script>
</body>
</html>